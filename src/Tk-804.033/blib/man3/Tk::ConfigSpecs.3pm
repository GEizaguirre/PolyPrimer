.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "ConfigSpecs 3pm"
.TH ConfigSpecs 3pm "2018-12-25" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Tk::ConfigSpecs \- Defining behaviour of 'configure' for composite widgets.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&    sub Populate
\&    {
\&     my ($composite,$args) = @_;
\&     ...
\&     $composite\->ConfigSpecs(\*(Aq\-attribute\*(Aq => [ where,dbName,dbClass,default ]);
\&     $composite\->ConfigSpecs(\*(Aq\-alias\*(Aq => \*(Aq\-otherattribute\*(Aq);
\&     $composite\->ConfigSpecs(\*(AqDEFAULT\*(Aq => [ where ]);
\&     $composite\->ConfigSpecs($subwidget\->ConfigSpecs);
\&     ...
\&    }
\&
\&    $composite\->configure(\-attribute => value);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The aim is to make the composite widget configure method look as much like
a regular Tk widget's configure as possible.
(See Tk::options for a description of this behaviour.)
To enable this the attributes that the composite as a whole accepts
needs to be defined.
.SS "Defining the ConfigSpecs for a class."
.IX Subsection "Defining the ConfigSpecs for a class."
Typically a widget will have one or more calls like the following
.PP
.Vb 1
\&    $composite\->ConfigSpecs(\-attribute => [where,dbName,dbClass,default]);
.Ve
.PP
in its \fBPopulate\fR method. When \fBConfigSpecs\fR is called this way
(with arguments) the arguments are used to construct or augment/replace
a hash table for the widget. (More than one \fI\-option\fR=>\fIvalue\fR
pair can be specified to a single call.)
.PP
\&\fBdbName\fR, \fBdbClass\fR and default are only used by \fBConfigDefault\fR described
below, or to respond to 'inquiry' configure commands.
.PP
It may be either one of the values below, or a list of such values
enclosed in \fB[]\fR.
.PP
The currently permitted values of \fBwhere\fR are:
.IP "\fB'\s-1ADVERTISED\s0'\fR" 4
.IX Item "'ADVERTISED'"
Apply \fBconfigure\fR to \fIadvertised\fR subwidgets.
.IP "\fB'\s-1DESCENDANTS\s0'\fR" 4
.IX Item "'DESCENDANTS'"
Apply \fBconfigure\fR recursively to all descendants.
.IP "\fB'\s-1CALLBACK\s0'\fR" 4
.IX Item "'CALLBACK'"
Setting the attribute does \f(CW\*(C`Tk::Callback\->new($value)\*(C'\fR before storing
in \f(CW\*(C`$composite\->{Configure}{\-attribute}\*(C'\fR. This is appropriate for
\&\f(CW\*(C`\-command => ...\*(C'\fR attributes that are handled by the composite and not
forwarded to a subwidget. (E.g. \fBTk::Tiler\fR has \f(CW\*(C`\-yscrollcommand\*(C'\fR to
allow it to have scrollbar attached.)
.Sp
This may be the first of several 'validating' keywords (e.g. font, cursor,
anchor etc.) that core Tk makes special for C code.
.IP "\fB'\s-1CHILDREN\s0'\fR" 4
.IX Item "'CHILDREN'"
Apply \fBconfigure\fR to all children.  (Children are the immediate
descendants of a widget.)
.IP "\fB'\s-1METHOD\s0'\fR" 4
.IX Item "'METHOD'"
Call \f(CW\*(C`$cw\->attribute(value)\*(C'\fR
.Sp
This is the most general case. Simply have a method of the composite
class with the same name as the attribute.  The method may do any
validation and have whatever side-effects you like.  (It is probably
worth 'queueing' using \fBafterIdle\fR for more complex side-effects.)
.IP "\fB'\s-1PASSIVE\s0'\fR" 4
.IX Item "'PASSIVE'"
Simply store value in \f(CW\*(C`$composite\->{Configure}{\-attribute}\*(C'\fR.
.Sp
This form is also a useful placeholder for attributes which you
currently only handle at create time.
.IP "\fB'\s-1SELF\s0'\fR" 4
.IX Item "'SELF'"
Apply \fBconfigure\fR to the core widget (e.g. \fBFrame\fR) that is the basis of
the composite. (This is the default behaviour for most attributes which
makes a simple Frame behave the way you would expect.) Note that once
you have specified \fBConfigSpecs\fR for an attribute you must explicitly
include \f(CW\*(AqSELF\*(Aq\fR in the list if you want the attribute to apply to the
composite itself (this avoids nasty infinite recursion problems).
.IP "\fB\f(CB$reference\fB\fR (blessed)" 4
.IX Item "$reference (blessed)"
Call \fB\f(CB$reference\fB\fR\->configure(\-attribute => value)
.Sp
A common case is where \fB\f(CB$reference\fB\fR is a subwidget.
.Sp
\&\f(CW$reference\fR may also be result of
.Sp
.Vb 1
\&     Tk::Config\->new(setmethod,getmethod,args,...);
.Ve
.Sp
\&\fBTk::Config\fR class is used to implement all the above keyword types.  The
class has \f(CW\*(C`configure\*(C'\fR and \f(CW\*(C`cget\*(C'\fR methods so allows higher level code to
\&\fIalways\fR just call one of those methods on an \fIobject\fR of some kind.
.IP "\fBhash reference\fR" 4
.IX Item "hash reference"
Defining:
.Sp
.Vb 6
\&        $cw\->ConfigSpecs(
\&                ...
\&                \-option => [ { \-optionX=>$w1, \-optionY=>[$w2, $w3] },
\&                                dbname dbclass default ],
\&                ...
\&                );
.Ve
.Sp
So \f(CW\*(C`$cw\->configure(\-option => value)\*(C'\fR actually does
.Sp
.Vb 3
\&        $w1\->configure(\-optionX => value);
\&        $w2\->configure(\-optionY => value);
\&        $w3\->configure(\-optionY => value);
.Ve
.IP "\fB'otherstring'\fR" 4
.IX Item "'otherstring'"
Call
.Sp
.Vb 1
\&    $composite\->Subwidget(\*(Aqotherstring\*(Aq)\->configure( \-attribute => value );
.Ve
.Sp
While this is here for backward compatibility with Tk\-b5, it is probably
better just to use the subwidget reference directly.  The only
case for retaining this form is to allow an additional layer of
abstraction \- perhaps having a 'current' subwidget \- this is unproven.
.IP "\fBAliases\fR" 4
.IX Item "Aliases"
\&\f(CW\*(C`ConfigSpecs( \-alias => \*(Aq\-otherattribute\*(Aq )\*(C'\fR is used to make \f(CW\*(C`\-alias\*(C'\fR
equivalent to \f(CW\*(C`\-otherattribute\*(C'\fR. For example the aliases
.Sp
.Vb 2
\&    \-fg => \*(Aq\-foreground\*(Aq,
\&    \-bg => \*(Aq\-background\*(Aq
.Ve
.Sp
are provided automatically (if not already specified).
.SS "Delegating all options of a widget class to a subwidget"
.IX Subsection "Delegating all options of a widget class to a subwidget"
.Vb 1
\&    $composite\->ConfigSpecs($subwidget\->ConfigSpecs);
.Ve
.PP
The above generates a list of \fIcomposite\fR ConfigSpecs arguments, one
for each valid option in \f(CW$subwidget\fR's class, and delegates said option
to \f(CW$subwidget\fR.  See Tk::Widget and the \fIwidget\fR method
ConfigSpecs.  Duplicating \fIcomposite\fR ConfigSpecs and \fIwidget\fR
ConfigSpecs keys will yield undefined results.
.SS "Default values"
.IX Subsection "Default values"
When the \fBPopulate\fR method returns \fBConfigDefault\fR is called.  This calls
.PP
.Vb 1
\&    $composite\->ConfigSpecs;
.Ve
.PP
(with no arguments) to return a reference to a hash. Entries in the hash
take the form:
.PP
.Vb 1
\&    \*(Aq\-attribute\*(Aq => [ where, dbName, dbClass, default ]
.Ve
.PP
\&\fBConfigDefault\fR ignores 'where' completely (and also the \s-1DEFAULT\s0 entry) and
checks the 'options' database on the widget's behalf, and if an entry is
present matching dbName/dbClass
.PP
.Vb 1
\&    \-attribute => value
.Ve
.PP
is added to the list of options that \fBnew\fR will eventually apply to the
widget. Likewise if there is not a match and default is defined this
default value will be added.
.PP
Alias entries in the hash are used to convert user-specified values for the
alias into values for the real attribute.
.SS "\fB\fP\f(BINew()\fP\fB\-time configure\fP"
.IX Subsection "New()-time configure"
Once control returns to \fBnew\fR, the list of user-supplied options
augmented by those from \fBConfigDefault\fR are applied to the widget using the
\&\fBconfigure\fR method below.
.PP
Widgets are most flexible and most Tk-like if they handle the majority of
their attributes this way.
.SS "Configuring composites"
.IX Subsection "Configuring composites"
Once the above have occurred calls of the form:
.PP
.Vb 1
\&    $composite\->configure( \-attribute => value );
.Ve
.PP
should behave like any other widget as far as end-user code is concerned.
\&\fBconfigure\fR will be handled by \fBTk::Derived::configure\fR as follows:
.PP
.Vb 1
\&    $composite\->ConfigSpecs;
.Ve
.PP
is called (with no arguments) to return a reference to a hash \fB\-attribute\fR is
looked up in this hash, if \fB\-attribute\fR is not present in the hash then
\&\fB'\s-1DEFAULT\s0'\fR is looked for instead.  (Aliases are tried as well and cause
redirection to the aliased attribute).  The result should be a reference to a
list like:
.PP
.Vb 1
\&  [ where, dbName, dbClass, default ]
.Ve
.PP
at this stage only \fIwhere\fR is of interest, it maps to a list of object
references (maybe only one) foreach one
.PP
.Vb 1
\&   $object\->configure( \-attribute => value );
.Ve
.PP
is \fBeval\fRed.
.SS "Inquiring attributes of composites"
.IX Subsection "Inquiring attributes of composites"
.Vb 1
\&   $composite\->cget( \*(Aq\-attribute\*(Aq );
.Ve
.PP
This is handled by  \fBTk::Derived::cget\fR in a similar manner to configure. At
present if \fIwhere\fR is a list of more than one object it is ignored completely
and the \*(L"cached\*(R" value in
.PP
.Vb 1
\&   $composite\->{Configure}{\-attribute}.
.Ve
.PP
is returned.
.SH "CAVEATS"
.IX Header "CAVEATS"
The \f(CW\*(C`\-background\*(C'\fR and \f(CW\*(C`\-foreground\*(C'\fR option values are automatically
propagated down to all composite widget's children. This may be
sometimes not desirable, especially if some subwidgets should use own
color schemes, either by using explicit options or by option database
definitions. If this is the case, then just add
.PP
.Vb 2
\&    \-foreground => \*(AqSELF\*(Aq,
\&    \-background => \*(AqSELF\*(Aq,
.Ve
.PP
to \f(CW\*(C`ConfigSpecs\*(C'\fR.
.PP
It is the author's intention to port as many of the \*(L"Tix\*(R" composite widgets
as make sense. The mechanism described above may have to evolve in order to
make this possible, although now aliases are handled I think the above is
sufficient.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Tk::composite,
Tk::options,
Tk::Widget
