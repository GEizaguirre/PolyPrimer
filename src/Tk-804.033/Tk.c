/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.34 from the
 * contents of Tk.xs. Do not edit this file, edit Tk.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Tk.xs"
/*
  Copyright (c) 1995-2004 Nick Ing-Simmons. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
*/
#define PERL_NO_GET_CONTEXT
#include <EXTERN.h>
#include <perl.h>
#include <XSUB.h>
#include <patchlevel.h>

#include "tkGlue.def"

static STRLEN na; /* Quick and dirty fix */

#include "pTk/tkPort.h"
#include "pTk/tkInt.h"
#include "pTk/tkFont.h"
#include "pTk/tkXrm.h"
#include "pTk/default.h"

#if defined(__WIN32__) && !defined(__EMX__)
#  include "pTk/tkWinInt.h"
#endif

#include "tkGlue.h"

#ifdef NEED_PRELOAD
#ifdef I_DLFCN
#include <dlfcn.h>	/* the dynamic linker include file for Sunos/Solaris */
#else
#include <nlist.h>
#include <link.h>
#endif
#define NeedPreload() 1
#else

#define NeedPreload() 0
#endif

#define Tk_tainting() (PL_tainting)
#define Tk_tainted(sv) ((sv) ? SvTAINTED(sv) : PL_tainted)

static void
DebugHook(SV *sv)
{

}

#define XEvent_DESTROY(obj)

#define Tk_XRaiseWindow(w) XRaiseWindow(Tk_Display(w),Tk_WindowId(w))

#define Const_DONT_WAIT()     (TCL_DONT_WAIT)
#define Const_WINDOW_EVENTS() (TCL_WINDOW_EVENTS)
#define Const_FILE_EVENTS()   (TCL_FILE_EVENTS)
#define Const_TIMER_EVENTS()  (TCL_TIMER_EVENTS)
#define Const_IDLE_EVENTS()   (TCL_IDLE_EVENTS)
#define Const_ALL_EVENTS()    (TCL_ALL_EVENTS)

#ifndef SELECT_FG
/* Should really depend on color/mono */
#define SELECT_FG BLACK
#endif

#define Const_NORMAL_BG()     (NORMAL_BG)
#define Const_ACTIVE_BG()     (ACTIVE_BG)
#define Const_SELECT_BG()     (SELECT_BG)
#define Const_SELECT_FG()     (SELECT_FG)
#define Const_TROUGH()        (TROUGH)
#define Const_INDICATOR()     (INDICATOR)
#define Const_DISABLED()      (DISABLED)
#define Const_BLACK()         (BLACK)
#define Const_WHITE()         (WHITE)

static XFontStruct * TkwinFont _((Tk_Window tkwin, Tk_Uid name));

#define pTk_Synchronize(win,flag) \
   XSynchronize(Tk_Display(win), flag)

static IV
PointToWindow(Tk_Window tkwin, int x, int y, Window dest)
{
 Display *dpy = Tk_Display(tkwin);
 Window root = RootWindowOfScreen(Tk_Screen(tkwin));
 Window win = None;
 if (dest == None)
  dest = root;
#ifdef WIN32
 { 
  HWND hwnd = (HWND) Tk_GetHWND(dest);
  RECT  r;
  if (GetWindowRect(hwnd,&r))
   { 
    POINT pt;
    HWND child;
    pt.x = x - r.left;
    pt.y = y - r.top;
    child = ChildWindowFromPoint(hwnd, pt);
    if (child != hwnd)
     {
      TkWindow *winPtr = (TkWindow *) Tk_HWNDToWindow(child);
      if (winPtr) 
       {
        win = winPtr->window;
      } 
     }
   } 
  return (IV) win;
 }
#else
 if (!XTranslateCoordinates(dpy, root, dest, x, y, &x, &y, &win))
  {
   win = None;
  }
 return (IV) win;
#endif
}

static SV *
StringAlias(pTHX_ const char *s)
{
 SV *sv = newSV(0);
 sv_upgrade(sv,SVt_PV);
 SvPVX(sv) = (char *) s;
 SvCUR_set(sv,strlen(s));
 SvLEN(sv) = 0;
 SvPOK_only(sv);
 SvREADONLY_on(sv);
 return sv;
}

typedef struct
{
 CONST char *foundary;
 CONST char *encoding;
 TkFontAttributes attrib;
 const char *name;
} LangFontInfo;

static SV *
FontInfo(pTHX_ const char *encoding, const char *foundary,
         const TkFontAttributes *attrib, const char *name)
{
 SV *sv = newSV(sizeof(LangFontInfo));
 LangFontInfo *info = (LangFontInfo *) SvPVX(sv);
 SvCUR_set(sv,sizeof(LangFontInfo));
 SvPOK_only(sv);
 info->encoding = encoding;
 info->foundary = foundary;
 info->attrib   = *attrib;
 /* FIXME */
 info->name     = name;
 return sv_bless(newRV_noinc(sv),gv_stashpv("Tk::FontRankInfo", TRUE));
}

#define Boolean int

#define FontInfo_encoding(p) (StringAlias(aTHX_ (p)->encoding))
#define FontInfo_foundary(p) (StringAlias(aTHX_ (p)->foundary))
#define FontInfo_Xname(p)    (StringAlias(aTHX_ (p)->name))
#define FontInfo_family(p)   (StringAlias(aTHX_ (p)->attrib.family))
#define FontInfo_size(p)     ((p)->attrib.size)
#define FontInfo_bold(p)     ((p)->attrib.weight == TK_FW_BOLD)
#define FontInfo_italic(p)   ((p)->attrib.slant  == TK_FS_ITALIC)

unsigned int
LangFontRank(unsigned int suggested,
	     int ch,
	     CONST char *gotName,
	     CONST char *wantFoundary,
	     CONST TkFontAttributes *wantAttrib,
	     CONST char *wantEncoding,
	     CONST char *gotFoundary,
	     CONST TkFontAttributes *gotAttrib,
	     CONST char *gotEncoding)
{
 dTHX;
 SV *hook = get_sv("Tk::FontRank",0);
 if (hook && SvOK(hook))
  {
   dSP;
   int flags = (suggested == 0 || suggested == (unsigned int) -1)
                ? G_VOID : G_SCALAR;
   SV *result, *sv;
   int count;
   ENTER;
   SAVETMPS;
   LangPushCallbackArgs(&hook);
   result = Nullsv;
   sv = newSV(UTF8_MAXLEN);
   sv_upgrade(sv,SVt_PVIV);
#ifdef UNICODE_ALLOW_ANY
   count = uvchr_to_utf8_flags((U8 *) SvPVX(sv),ch, UNICODE_ALLOW_ANY)
               - (U8 *) SvPVX(sv);
#else
   count = Perl_uv_to_utf8(aTHX_ (U8 *) SvPVX(sv),ch) - (U8 *) SvPVX(sv);
#endif
   SvCUR_set(sv,count);
   SvPOK_on(sv);
   SvUTF8_on(sv);
   SvIVX(sv) = ch;
   SvIOK_on(sv);
   SPAGAIN;
   XPUSHs(sv_2mortal(newSViv((IV) suggested)));
   XPUSHs(sv_2mortal(sv));
   XPUSHs(sv_2mortal(FontInfo(aTHX_ wantEncoding, wantFoundary, wantAttrib, Nullch)));
   XPUSHs(sv_2mortal(FontInfo(aTHX_ gotEncoding, gotFoundary, gotAttrib,gotName)));
   PUTBACK;
   if ((count  = LangCallCallback(hook, G_EVAL | flags)))
    {
     SPAGAIN;
     result = POPs;
     PUTBACK;
    }
   if (SvTRUE(ERRSV))
    {
     warn("%"SVf,ERRSV);
     sv_setsv(hook,&PL_sv_undef);
    }
   else
    {
     if (result && SvOK(result))
      {
       if (SvPOK(result) && !SvCUR(result))
        {
         suggested = (unsigned int) -2;
        }
       else
        suggested = (unsigned int) SvIV(result);
      }
     else
      {
       suggested = (unsigned int) -1;
      }
    }
   FREETMPS;
   LEAVE;
  }
 /* Placeholder for a hook */
 if (0 && !suggested)
  LangDebug("%08x for U+%04x %s from %s\n",suggested,ch, gotEncoding, gotName);
 return suggested;
}


#line 257 "Tk.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%" UVxf ")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 401 "Tk.c"

XS_EUPXS(XS_Tk__FontRankInfo_encoding); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__FontRankInfo_encoding)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "p");
    {
	SV *	RETVAL;
	LangFontInfo *	p;

	if (sv_isobject(ST(0))) {
	    STRLEN sz;
	    p = (LangFontInfo *) SvPV((SV*)SvRV(ST(0)),sz);
	    if (sz != sizeof(*p))
	     croak("ST(0) too small (%d) for p LangFontInfo * (%d)",sz,sizeof(*p));
	}
	else
	    croak("p is not an object")
;

	RETVAL = FontInfo_encoding(p);
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__FontRankInfo_foundary); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__FontRankInfo_foundary)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "p");
    {
	SV *	RETVAL;
	LangFontInfo *	p;

	if (sv_isobject(ST(0))) {
	    STRLEN sz;
	    p = (LangFontInfo *) SvPV((SV*)SvRV(ST(0)),sz);
	    if (sz != sizeof(*p))
	     croak("ST(0) too small (%d) for p LangFontInfo * (%d)",sz,sizeof(*p));
	}
	else
	    croak("p is not an object")
;

	RETVAL = FontInfo_foundary(p);
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__FontRankInfo_Xname); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__FontRankInfo_Xname)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "p");
    {
	SV *	RETVAL;
	LangFontInfo *	p;

	if (sv_isobject(ST(0))) {
	    STRLEN sz;
	    p = (LangFontInfo *) SvPV((SV*)SvRV(ST(0)),sz);
	    if (sz != sizeof(*p))
	     croak("ST(0) too small (%d) for p LangFontInfo * (%d)",sz,sizeof(*p));
	}
	else
	    croak("p is not an object")
;

	RETVAL = FontInfo_Xname(p);
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__FontRankInfo_family); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__FontRankInfo_family)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "p");
    {
	SV *	RETVAL;
	LangFontInfo *	p;

	if (sv_isobject(ST(0))) {
	    STRLEN sz;
	    p = (LangFontInfo *) SvPV((SV*)SvRV(ST(0)),sz);
	    if (sz != sizeof(*p))
	     croak("ST(0) too small (%d) for p LangFontInfo * (%d)",sz,sizeof(*p));
	}
	else
	    croak("p is not an object")
;

	RETVAL = FontInfo_family(p);
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__FontRankInfo_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__FontRankInfo_size)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "p");
    {
	int	RETVAL;
	dXSTARG;
	LangFontInfo *	p;

	if (sv_isobject(ST(0))) {
	    STRLEN sz;
	    p = (LangFontInfo *) SvPV((SV*)SvRV(ST(0)),sz);
	    if (sz != sizeof(*p))
	     croak("ST(0) too small (%d) for p LangFontInfo * (%d)",sz,sizeof(*p));
	}
	else
	    croak("p is not an object")
;

	RETVAL = FontInfo_size(p);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__FontRankInfo_bold); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__FontRankInfo_bold)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "p");
    {
	Boolean	RETVAL;
	LangFontInfo *	p;

	if (sv_isobject(ST(0))) {
	    STRLEN sz;
	    p = (LangFontInfo *) SvPV((SV*)SvRV(ST(0)),sz);
	    if (sz != sizeof(*p))
	     croak("ST(0) too small (%d) for p LangFontInfo * (%d)",sz,sizeof(*p));
	}
	else
	    croak("p is not an object")
;

	RETVAL = FontInfo_bold(p);
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__FontRankInfo_italic); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__FontRankInfo_italic)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "p");
    {
	Boolean	RETVAL;
	LangFontInfo *	p;

	if (sv_isobject(ST(0))) {
	    STRLEN sz;
	    p = (LangFontInfo *) SvPV((SV*)SvRV(ST(0)),sz);
	    if (sz != sizeof(*p))
	     croak("ST(0) too small (%d) for p LangFontInfo * (%d)",sz,sizeof(*p));
	}
	else
	    croak("p is not an object")
;

	RETVAL = FontInfo_italic(p);
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk_BLACK); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_BLACK)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	char *	RETVAL;
	dXSTARG;

	RETVAL = Const_BLACK();
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk_WHITE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_WHITE)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	char *	RETVAL;
	dXSTARG;

	RETVAL = Const_WHITE();
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk_NORMAL_BG); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_NORMAL_BG)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	char *	RETVAL;
	dXSTARG;

	RETVAL = Const_NORMAL_BG();
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk_ACTIVE_BG); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_ACTIVE_BG)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	char *	RETVAL;
	dXSTARG;

	RETVAL = Const_ACTIVE_BG();
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk_SELECT_BG); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_SELECT_BG)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	char *	RETVAL;
	dXSTARG;

	RETVAL = Const_SELECT_BG();
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk_SELECT_FG); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_SELECT_FG)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	char *	RETVAL;
	dXSTARG;

	RETVAL = Const_SELECT_FG();
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk_TROUGH); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_TROUGH)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	char *	RETVAL;
	dXSTARG;

	RETVAL = Const_TROUGH();
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk_INDICATOR); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_INDICATOR)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	char *	RETVAL;
	dXSTARG;

	RETVAL = Const_INDICATOR();
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk_DISABLED); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_DISABLED)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	char *	RETVAL;
	dXSTARG;

	RETVAL = Const_DISABLED();
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk_DONT_WAIT); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_DONT_WAIT)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	IV	RETVAL;
	dXSTARG;

	RETVAL = Const_DONT_WAIT();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk_WINDOW_EVENTS); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_WINDOW_EVENTS)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	IV	RETVAL;
	dXSTARG;

	RETVAL = Const_WINDOW_EVENTS();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk_FILE_EVENTS); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_FILE_EVENTS)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	IV	RETVAL;
	dXSTARG;

	RETVAL = Const_FILE_EVENTS();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk_TIMER_EVENTS); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_TIMER_EVENTS)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	IV	RETVAL;
	dXSTARG;

	RETVAL = Const_TIMER_EVENTS();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk_IDLE_EVENTS); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_IDLE_EVENTS)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	IV	RETVAL;
	dXSTARG;

	RETVAL = Const_IDLE_EVENTS();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk_ALL_EVENTS); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_ALL_EVENTS)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	IV	RETVAL;
	dXSTARG;

	RETVAL = Const_ALL_EVENTS();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Xrm_import); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Xrm_import)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "class, ...");
    {
	char *	class = (char *)SvPV_nolen(ST(0))
;

	Xrm_import(class);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_XEvent_Info); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_XEvent_Info)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "obj, s");
    {
	EventAndKeySym *	obj = SVtoEventAndKeySym(ST(0))
;
	char *	s = (char *)SvPV_nolen(ST(1))
;
#line 335 "Tk.xs"
{
 ST(0) = XEvent_Info(obj,s);
}
#line 883 "Tk.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_XEvent_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_XEvent_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "obj");
    {
	SV *	obj = ST(0)
;

	XEvent_DESTROY(obj);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk__MainWindow_Synchronize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__MainWindow_Synchronize)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "win, flag = True");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	int	flag;

	if (items < 2)
	    flag = True;
	else {
	    flag = (int)SvIV(ST(1))
;
	}

	pTk_Synchronize(win, flag);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk__MainWindow_Count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__MainWindow_Count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0)
;
	int	RETVAL;
	dXSTARG;
#line 356 "Tk.xs"
 {
  ST(0) = sv_2mortal(newSViv(Tk_GetNumMainWindows()));
 }
#line 944 "Tk.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Callback_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Callback_new)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "package, what");
    {
	char *	package = (char *)SvPV_nolen(ST(0))
;
	SV *	what = ST(1)
;
#line 368 "Tk.xs"
 {
  ST(0) = sv_2mortal(sv_bless(LangMakeCallback(what),gv_stashpv(package, TRUE)));
 }
#line 965 "Tk.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Callback_Substitute); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Callback_Substitute)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "cb, src, dst");
    {
	SV *	cb = ST(0)
;
	SV *	src = ST(1)
;
	SV *	dst = ST(2)
;
#line 378 "Tk.xs"
{
 if (!SvROK(cb))
  croak("callback is not a reference");
 cb = SvRV(cb);
 if (!SvROK(src))
  croak("src is not a reference");
 src = SvRV(src);
 if (!SvROK(dst))
  croak("dst is not a reference");

 if (SvTYPE(cb) == SVt_PVAV)
  {
   AV *av = newAV();
   int n = av_len((AV *) cb);
   int i;
   int match = 0;
   for (i=0; i <= n; i++)
    {
     SV **svp = av_fetch((AV *) cb,i,0);
     if (svp)
      {
       if (SvROK(*svp) && SvRV(*svp) == src)
        {
         av_store(av, i, SvREFCNT_inc(dst));
         match++;
        }
       else
        {
         av_store(av, i, SvREFCNT_inc(*svp));
        }
      }
    }
   if (match)
    {
     ST(0) = sv_2mortal(sv_bless(MakeReference((SV *) av),SvSTASH(cb)));
    }
   else
    {
     SvREFCNT_dec(av);
    }
  }
}
#line 1027 "Tk.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk_NeedPreload); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_NeedPreload)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = NeedPreload();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk_Preload); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_Preload)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "filename");
    {
	char *	filename = (char *)SvPV_nolen(ST(0))
;
#line 430 "Tk.xs"
#ifdef NEED_PRELOAD
    void *h = dlopen(filename, RTLD_LAZY|RTLD_GLOBAL) ;
    if (!h)
     croak("Cannot load %s",filename);
#endif
#line 1065 "Tk.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk_timeofday); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_timeofday)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	double	RETVAL;
	dXSTARG;
#line 439 "Tk.xs"
{
 Tcl_Time t;
 Tcl_GetTime(&t);
 RETVAL = t.sec + (double) t.usec/1e6;
}
#line 1086 "Tk.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk_GetFocusWin); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_GetFocusWin)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	TkWindow *	win = (TkWindow *) SVtoWindow(ST(0))
;
	TkWindow *	RETVAL;

	RETVAL = TkGetFocusWin(win);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    SvSetMagicSV(RETVALSV,TkToWidget((Tk_Window) RETVAL,NULL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk_GetPointerCoords); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_GetPointerCoords)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
#line 455 "Tk.xs"
 {
  int x, y;
  TkGetPointerCoords(win, &x, &y);
  PUSHs(sv_2mortal(newSViv(x)));
  PUSHs(sv_2mortal(newSViv(y)));
 }
#line 1134 "Tk.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Tk_CheckHash); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_CheckHash)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "widget");
    {
	SV *	widget = ST(0)
;
#line 468 "Tk.xs"
 {
  Tk_CheckHash(widget,NULL);
 }
#line 1154 "Tk.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk_Debug); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_Debug)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "widget, string");
    {
	SV *	widget = ST(0)
;
	char *	string = (char *)SvPV_nolen(ST(1))
;
#line 477 "Tk.xs"
 {
  LangDumpVec(string,1,&SvRV(widget));
 }
#line 1175 "Tk.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk_WidgetMethod); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_WidgetMethod)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "widget, name, ...");
    {
	SV *	widget = ST(0)
;
	SV *	name = ST(1)
;
#line 486 "Tk.xs"
 {
  Lang_CmdInfo *info = WindowCommand(widget, NULL, 1);
  TKXSRETURN(Call_Tk(info, items, &ST(0)));
 }
#line 1197 "Tk.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk_OldEnterMethods); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_OldEnterMethods)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "package, file, ...");
    {
	char *	package = (char *)SvPV_nolen(ST(0))
;
	char *	file = (char *)SvPV_nolen(ST(1))
;
#line 496 "Tk.xs"
 {int i;
  char buf[80];  /* FIXME Size of buffer */
  for (i=2; i < items; i++)
   {
    STRLEN len;
    SV *method = newSVsv(ST(i));
    CV *cv;
    sprintf(buf, "%s::%s", package, SvPV(method,len));
    cv = newXS(buf, XStoWidget, file);
    CvXSUBANY(cv).any_ptr = method;
   }
 }
#line 1227 "Tk.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk_GetFILE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_GetFILE)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "arg, w");
    {
	SV *	arg = ST(0)
;
	int	w = (int)SvIV(ST(1))
;
	IV	RETVAL;
	dXSTARG;
#line 514 "Tk.xs"
 {
  IO *io = sv_2io(arg);
  RETVAL = -1;
  if (io)
   {
    PerlIO *f = (w) ? IoOFP(io) : IoIFP(io);
    if (f)
     {
      RETVAL = PerlIO_fileno(f);
     }
   }
 }
#line 1259 "Tk.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Widget_PointToWindow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_PointToWindow)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "tkwin, x, y, parent = None");
    {
	Tk_Window	tkwin = SVtoWindow(ST(0))
;
	int	x = (int)SvIV(ST(1))
;
	int	y = (int)SvIV(ST(2))
;
	IV	parent;
	IV	RETVAL;
	dXSTARG;

	if (items < 4)
	    parent = None;
	else {
	    parent = (IV)SvIV(ST(3))
;
	}

	RETVAL = PointToWindow(tkwin, x, y, parent);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Widget_WindowXY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_WindowXY)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "tkwin, src = None, dst = None");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Tk_Window	tkwin = SVtoWindow(ST(0))
;
	IV	src;
	IV	dst;

	if (items < 2)
	    src = None;
	else {
	    src = (IV)SvIV(ST(1))
;
	}

	if (items < 3)
	    dst = None;
	else {
	    dst = (IV)SvIV(ST(2))
;
	}
#line 544 "Tk.xs"
{
 Display *dpy = Tk_Display(tkwin);
 Window root = RootWindowOfScreen(Tk_Screen(tkwin));
 int x = 0;
 int y = 0;
 if (src == None)
  src = Tk_WindowId(tkwin);
 if (dst == None)
  dst = root;
 XTranslateCoordinates(dpy, src, dst, 0, 0, &x, &y, &root);
 XPUSHs(sv_2mortal(newSViv(x)));
 XPUSHs(sv_2mortal(newSViv(y)));
}
#line 1338 "Tk.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Tk__Widget_DefineBitmap); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_DefineBitmap)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "tkwin, name, width, height, source");
    {
	Tk_Window	tkwin = SVtoWindow(ST(0))
;
	char *	name = (char *)SvPV_nolen(ST(1))
;
	int	width = (int)SvIV(ST(2))
;
	int	height = (int)SvIV(ST(3))
;
	SV *	source = ST(4)
;
#line 566 "Tk.xs"
{
 Tcl_Interp *interp;
 if (TkToWidget(tkwin,&interp) && interp)
  {STRLEN len;
   unsigned char *data = (unsigned char *) SvPV(source, len);
   STRLEN byte_line = (width + 7) / 8;
   if (len == height * byte_line)
    {
     Tcl_ResetResult(interp);
     if (Tk_DefineBitmap(interp, Tk_GetUid(name), data, width, height) != TCL_OK)
      croak("%s",Tcl_GetStringResult(interp));
    }
   else
    {
     croak("Data wrong size for %dx%d bitmap",width,height);
    }
  }
 else
  {
   croak("Invalid widget");
  }
}
#line 1385 "Tk.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk__Widget_GetBitmap); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_GetBitmap)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "tkwin, name");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Tk_Window	tkwin = SVtoWindow(ST(0))
;
	char *	name = (char *)SvPV_nolen(ST(1))
;
#line 594 "Tk.xs"
 {
  Tcl_Interp *interp;
  Pixmap pixmap;
  if (TkToWidget(tkwin,&interp) && interp)
   {
    pixmap = Tk_GetBitmap(interp, tkwin, name);
    if (pixmap == None)
     PUSHs(&PL_sv_undef);
    else
     PUSHs(sv_2mortal(newSViv((IV)pixmap)));
   }
  else
   {
    croak("Invalid widget");
   }
 }
#line 1421 "Tk.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Tk__Widget_UnmanageGeometry); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_UnmanageGeometry)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
#line 618 "Tk.xs"
 {
  Tk_ManageGeometry(win, NULL, NULL);
 }
#line 1441 "Tk.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk__Widget_DisableButtonEvents); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_DisableButtonEvents)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
#line 626 "Tk.xs"
 {
  Tk_Attributes(win)->event_mask
    &= ~(ButtonPressMask | ButtonReleaseMask | ButtonMotionMask);
  Tk_ChangeWindowAttributes(win, CWEventMask, Tk_Attributes(win));
 }
#line 1462 "Tk.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk__Widget_MakeAtom); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_MakeAtom)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "win, ...");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
#line 636 "Tk.xs"
 {
  int i;
  for (i=1; i < items; i++)
   {
    SV *sv = ST(i);
    Atom a = None;
    const char *name = Nullch;
    if (SvGMAGICAL(sv))
     mg_get(sv);
    if (SvIOK(sv) && !SvPOK(sv))
     {
      a = (Atom) SvIVX(sv);
      if (a != None)
       {
        sv_upgrade(sv,SVt_PVIV);
        name = Tk_GetAtomName(win,a);
        sv_setpvn(sv,name,strlen(name));
        SvIVX(sv) = (IV) a;
        SvIOK_on(sv);
       }
     }
    else if (SvPOK(sv) && !SvIOK(sv))
     {
      name = SvPVX(sv);
      if (name && *name)
       {
        sv_upgrade(sv,SVt_PVIV);
        a = Tk_InternAtom(win,name);
        SvIVX(sv) = (IV) a;
        SvIOK_on(sv);
       }
     }
    else if (SvPOK(sv) && SvIOK(sv))
     {
      name = SvPVX(sv);
      a    = (Atom) SvIVX(sv);
      if (a != Tk_InternAtom(win,name))
       {
        croak("%s/%ld is not a valid atom for %s\n",name,a,Tk_PathName(win));
       }
     }
   }
 }
#line 1521 "Tk.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk__Widget_SendClientMessage); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_SendClientMessage)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "win, type, xid, format, data");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	char *	type = (char *)SvPV_nolen(ST(1))
;
	IV	xid = (IV)SvIV(ST(2))
;
	IV	format = (IV)SvIV(ST(3))
;
	SV *	data = ST(4)
;
	int	RETVAL;
	dXSTARG;
#line 689 "Tk.xs"
 {
  XClientMessageEvent cM;
  STRLEN len;
  char *s = SvPV(data,len);
  if (len > sizeof(cM.data))
   len = sizeof(cM.data);
  cM.type = ClientMessage;
  cM.serial  = 0;
  cM.send_event = 0;
  cM.display = Tk_Display(win);
  cM.window = xid;
  cM.message_type = Tk_InternAtom(win,type);
  cM.format = format;
  memmove(cM.data.b,s,len);
  if ((RETVAL = XSendEvent(cM.display, cM.window, False, NoEventMask, (XEvent *) & cM)))
   {
    /* XSync may be overkill - but need XFlush ... */
    XSync(cM.display, False);
   }
  else
   {
    croak("XSendEvent failed");
   }
 }
#line 1571 "Tk.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#if 0
#define XSubPPtmpAAAA 1


XS_EUPXS(XS_Tk__Widget_SendNetWMClientMessage); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_SendNetWMClientMessage)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "win, type, xid, format, data");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	char *	type = (char *)SvPV_nolen(ST(1))
;
	IV	xid = (IV)SvIV(ST(2))
;
	IV	format = (IV)SvIV(ST(3))
;
	SV *	data = ST(4)
;
	int	RETVAL;
	dXSTARG;
#line 725 "Tk.xs"
 {
/*
   It's not clear if this function should go into Perl/Tk. This
   function would make is possible to send some netwm messages, for
   example NET_WM_STATE_ABOVE:

   my($wrapper) = $toplevel->wrapper;
   my $_NET_WM_STATE_ADD = 1;
   my $data = pack("LLLLL", $_NET_WM_STATE_ADD, $w->InternAtom('_NET_WM_STATE_ABOVE'), 0, 0, 0);
   $w->SendNetWMClientMessage('_NET_WM_STATE', $wrapper, 32, $data);
*/
  XClientMessageEvent cM;
  Window root = RootWindowOfScreen(Tk_Screen(win));
  STRLEN len;
  char *s = SvPV(data,len);
  if (len > sizeof(cM.data))
   len = sizeof(cM.data);
  cM.type = ClientMessage;
  cM.serial  = 0;
  cM.send_event = 0;
  cM.display = Tk_Display(win);
  cM.window = xid;
  cM.message_type = Tk_InternAtom(win,type);
  cM.format = format;
  memmove(cM.data.b,s,len);
  if ((RETVAL = XSendEvent(cM.display, root, False, SubstructureNotifyMask|SubstructureRedirectMask, (XEvent *) & cM)))
   {
    /* XSync may be overkill - but need XFlush ... */
    XSync(cM.display, False);
   }
  else
   {
    croak("XSendEvent failed");
   }
 }
#line 1636 "Tk.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS_EUPXS(XS_Tk__Widget_XSync); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_XSync)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "win, flush");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	int	flush = (int)SvIV(ST(1))
;
#line 770 "Tk.xs"
 {
  XSync(Tk_Display(win),flush);
 }
#line 1659 "Tk.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk__Widget_GetRootCoords); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_GetRootCoords)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
#line 778 "Tk.xs"
 {
  int x, y;
  Tk_GetRootCoords(win, &x, &y);
  PUSHs(sv_2mortal(newSViv(x)));
  PUSHs(sv_2mortal(newSViv(y)));
 }
#line 1683 "Tk.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Tk__Widget_GetVRootGeometry); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_GetVRootGeometry)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
#line 789 "Tk.xs"
 {
  int x, y;
  int width, height;
  Tk_GetVRootGeometry(win, &x, &y, &width, &height);
  PUSHs(sv_2mortal(newSViv(x)));
  PUSHs(sv_2mortal(newSViv(y)));
  PUSHs(sv_2mortal(newSViv(width)));
  PUSHs(sv_2mortal(newSViv(height)));
 }
#line 1711 "Tk.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Tk__Widget_Colormap); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_Colormap)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	Colormap	RETVAL;

	RETVAL = Tk_Colormap(win);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_iv(RETVALSV, "Colormap", PTR2IV(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Widget_Display); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_Display)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	Display *	RETVAL;

	RETVAL = Tk_Display(win);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_iv(RETVALSV, "DisplayPtr", PTR2IV(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Widget_ScreenNumber); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_ScreenNumber)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = Tk_ScreenNumber(win);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Widget_Screen); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_Screen)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	Screen *	RETVAL;

	RETVAL = Tk_Screen(win);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_iv(RETVALSV, "ScreenPtr", PTR2IV(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Widget_Visual); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_Visual)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	Visual *	RETVAL;

	RETVAL = Tk_Visual(win);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_iv(RETVALSV, "VisualPtr", PTR2IV(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Widget_WindowId); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_WindowId)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	Window	RETVAL;

	RETVAL = Tk_WindowId(win);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_iv(RETVALSV, "Window", PTR2IV(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Widget_X); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_X)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = Tk_X(win);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Widget_Y); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_Y)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = Tk_Y(win);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Widget_ReqWidth); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_ReqWidth)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = Tk_ReqWidth(win);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Widget_ReqHeight); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_ReqHeight)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = Tk_ReqHeight(win);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Widget_Width); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_Width)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = Tk_Width(win);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Widget_Height); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_Height)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = Tk_Height(win);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Widget_IsMapped); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_IsMapped)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = Tk_IsMapped(win);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Widget_Depth); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_Depth)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = Tk_Depth(win);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Widget_InternalBorderWidth); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_InternalBorderWidth)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = Tk_InternalBorderWidth(win);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Widget_IsTopLevel); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_IsTopLevel)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = Tk_IsTopLevel(win);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Widget_Name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_Name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	const char *	RETVAL;
	dXSTARG;

	RETVAL = Tk_Name(win);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Widget_PathName); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_PathName)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	char *	RETVAL;
	dXSTARG;

	RETVAL = Tk_PathName(win);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Widget_Class); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_Class)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	const char *	RETVAL;
	dXSTARG;

	RETVAL = Tk_Class(win);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Widget_MakeWindowExist); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_MakeWindowExist)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;

	Tk_MakeWindowExist(win);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk__Widget_SetClass); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_SetClass)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "win, class");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	char *	class = (char *)SvPV_nolen(ST(1))
;

	Tk_SetClass(win, class);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk__Widget_MoveWindow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_MoveWindow)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "win, x, y");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	int	x = (int)SvIV(ST(1))
;
	int	y = (int)SvIV(ST(2))
;

	Tk_MoveWindow(win, x, y);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk__Widget_XRaiseWindow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_XRaiseWindow)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;

	Tk_XRaiseWindow(win);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk__Widget_MoveToplevelWindow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_MoveToplevelWindow)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "win, x, y");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	int	x = (int)SvIV(ST(1))
;
	int	y = (int)SvIV(ST(2))
;
#line 900 "Tk.xs"
 { 
  TkWindow *winPtr = (TkWindow *) win;
  if (!(winPtr->flags & TK_TOP_LEVEL))
   {
    croak("Tk_MoveToplevelWindow called with non-toplevel window");
   }
  Tk_MoveToplevelWindow(win,x,y);
 }
#line 2191 "Tk.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk__Widget_MoveResizeWindow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_MoveResizeWindow)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "win, x, y, width, height");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	int	x = (int)SvIV(ST(1))
;
	int	y = (int)SvIV(ST(2))
;
	int	width = (int)SvIV(ST(3))
;
	int	height = (int)SvIV(ST(4))
;

	Tk_MoveResizeWindow(win, x, y, width, height);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk__Widget_ResizeWindow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_ResizeWindow)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "win, width, height");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	int	width = (int)SvIV(ST(1))
;
	int	height = (int)SvIV(ST(2))
;

	Tk_ResizeWindow(win, width, height);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk__Widget_GeometryRequest); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_GeometryRequest)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "win, width, height");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	int	width = (int)SvIV(ST(1))
;
	int	height = (int)SvIV(ST(2))
;

	Tk_GeometryRequest(win, width, height);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk__Widget_MaintainGeometry); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_MaintainGeometry)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "slave, master, x, y, width, height");
    {
	Tk_Window	slave = SVtoWindow(ST(0))
;
	Tk_Window	master = SVtoWindow(ST(1))
;
	int	x = (int)SvIV(ST(2))
;
	int	y = (int)SvIV(ST(3))
;
	int	width = (int)SvIV(ST(4))
;
	int	height = (int)SvIV(ST(5))
;

	Tk_MaintainGeometry(slave, master, x, y, width, height);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk__Widget_SetGrid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_SetGrid)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "win, reqWidth, reqHeight, gridWidth, gridHeight");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	int	reqWidth = (int)SvIV(ST(1))
;
	int	reqHeight = (int)SvIV(ST(2))
;
	int	gridWidth = (int)SvIV(ST(3))
;
	int	gridHeight = (int)SvIV(ST(4))
;

	Tk_SetGrid(win, reqWidth, reqHeight, gridWidth, gridHeight);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk__Widget_UnmaintainGeometry); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_UnmaintainGeometry)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "slave, master");
    {
	Tk_Window	slave = SVtoWindow(ST(0))
;
	Tk_Window	master = SVtoWindow(ST(1))
;

	Tk_UnmaintainGeometry(slave, master);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk__Widget_MapWindow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_MapWindow)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;

	Tk_MapWindow(win);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk__Widget_UnmapWindow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_UnmapWindow)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;

	Tk_UnmapWindow(win);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk__Widget_UnsetGrid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_UnsetGrid)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;

	Tk_UnsetGrid(win);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk__Widget_AddOption); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_AddOption)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "win, name, value, priority");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	char *	name = (char *)SvPV_nolen(ST(1))
;
	char *	value = (char *)SvPV_nolen(ST(2))
;
	int	priority = (int)SvIV(ST(3))
;

	Tk_AddOption(win, name, value, priority);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk__Widget_GetAtomName); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_GetAtomName)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "win, atom");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	Atom	atom = (Atom)SvIV(ST(1))
;
	const char *	RETVAL;
	dXSTARG;

	RETVAL = Tk_GetAtomName(win, atom);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Widget_ClearSelection); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_ClearSelection)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "win, selection");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	Atom	selection = (Atom)SvIV(ST(1))
;

	Tk_ClearSelection(win, selection);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk__Widget_DisplayName); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_DisplayName)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	const char *	RETVAL;
	dXSTARG;

	RETVAL = Tk_DisplayName(win);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Widget_GetOption); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_GetOption)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "win, name, class");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	char *	name = (char *)SvPV_nolen(ST(1))
;
	char *	class = (char *)SvPV_nolen(ST(2))
;
	const char *	RETVAL;
	dXSTARG;

	RETVAL = Tk_GetOption(win, name, class);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Widget_InternAtom); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_InternAtom)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "win, name");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	char *	name = (char *)SvPV_nolen(ST(1))
;
	IV	RETVAL;
	dXSTARG;

	RETVAL = Tk_InternAtom(win, name);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Widget_Ungrab); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_Ungrab)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;

	Tk_Ungrab(win);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk__Widget_SetAppName); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_SetAppName)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "win, name");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	char *	name = (char *)SvPV_nolen(ST(1))
;
	const char *	RETVAL;
	dXSTARG;

	RETVAL = Tk_SetAppName(win, name);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Widget_IsWidget); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_IsWidget)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	SV *	win = ST(0)
;
	int	RETVAL;
	dXSTARG;
#line 1009 "Tk.xs"
 {
  if (!SvROK(win) || SvTYPE(SvRV(win)) != SVt_PVHV)
   RETVAL = 0;
  else
   {
    Lang_CmdInfo *info = WindowCommand(win,NULL,0);
    RETVAL = (info && info->tkwin);
   }
 }
#line 2559 "Tk.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Widget_Grab); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_Grab)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "win, global");
    {
	SV *	win = ST(0)
;
	int	global = (int)SvIV(ST(1))
;
	int	RETVAL;
	dXSTARG;
#line 1026 "Tk.xs"
 {
  Lang_CmdInfo *info = WindowCommand(win,NULL,3);
  RETVAL = Tk_Grab(info->interp,info->tkwin,global);
 }
#line 2584 "Tk.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Widget_Widget); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_Widget)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "win, path");
    {
	SV *	win = ST(0)
;
	char *	path = (char *)SvPV_nolen(ST(1))
;
	SV *	RETVAL;
#line 1036 "Tk.xs"
 {
  Lang_CmdInfo *info = WindowCommand(win,NULL,1);
  ST(0) = sv_mortalcopy(WidgetRef(info->interp,path));
 }
#line 2607 "Tk.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Widget__object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget__object)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "win, name");
    {
	SV *	win = ST(0)
;
	char *	name = (char *)SvPV_nolen(ST(1))
;
	SV *	RETVAL;
#line 1046 "Tk.xs"
 {
  Lang_CmdInfo *info = WindowCommand(win,NULL,1);
  ST(0) = sv_mortalcopy(ObjectRef(info->interp,name));
 }
#line 2630 "Tk.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Widget_Containing); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_Containing)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "win, X, Y");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	int	X = (int)SvIV(ST(1))
;
	int	Y = (int)SvIV(ST(2))
;
	Tk_Window	RETVAL;
#line 1057 "Tk.xs"
 {
  RETVAL = Tk_CoordsToWindow(X, Y, win);
 }
#line 2654 "Tk.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    SvSetMagicSV(RETVALSV,TkToWidget(RETVAL,NULL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Widget_Parent); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_Parent)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	Tk_Window	win = SVtoWindow(ST(0))
;
	Tk_Window	RETVAL;

	RETVAL = Tk_Parent(win);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    SvSetMagicSV(RETVALSV,TkToWidget(RETVAL,NULL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Widget_MainWindow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Widget_MainWindow)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "interp");
    {
	Tcl_Interp *	interp = WindowCommand(ST(0),NULL,1)->interp
;
	SV *	RETVAL;
#line 1071 "Tk.xs"
 {
  RETVAL = SvREFCNT_inc(WidgetRef(interp,"."));
 }
#line 2703 "Tk.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk_AddErrorInfo); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_AddErrorInfo)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "interp, message");
    {
	Tcl_Interp *	interp = WindowCommand(ST(0),NULL,1)->interp
;
	char *	message = (char *)SvPV_nolen(ST(1))
;

	Tcl_AddErrorInfo(interp, message);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk_BackgroundError); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_BackgroundError)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "interp");
    {
	Tcl_Interp *	interp = WindowCommand(ST(0),NULL,1)->interp
;

	Tcl_BackgroundError(interp);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk_Fail); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_Fail)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "interp, message");
    {
	Tcl_Interp *	interp = WindowCommand(ST(0),NULL,1)->interp
;
	char *	message = (char *)SvPV_nolen(ST(1))
;
#line 1093 "Tk.xs"
 {
  Tcl_SetResult(interp,message,TCL_VOLATILE);
  Tcl_BackgroundError(interp);
 }
#line 2761 "Tk.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk_DoOneEvent); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_DoOneEvent)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    {
	int	RETVAL;
	dXSTARG;
#line 1101 "Tk.xs"
 {
  int flags = 0;
  if (items)
   {int i;
    for (i=0; i < items; i++)
     {
      SV *sv = ST(i);
      if (SvIOK(sv) || looks_like_number(sv))
       flags |= SvIV(sv);
      else if (!sv_isobject(sv))
       {STRLEN l;
        char *s = SvPV(sv,l);
        if (strcmp(s,BASEEXT))
         {
          /* string to integer lookup here */
          croak("Usage [$object->]DoOneEvent([flags]) got '%s'\n",s);
         }
       }
     }
   }
  RETVAL = Tcl_DoOneEvent(flags);
 }
#line 2798 "Tk.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk__Font_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Font_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV *	sv = ST(0)
;

	Font_DESTROY(sv);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk__Font_PostscriptFontName); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk__Font_PostscriptFontName)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "tkfont, name");
    {
	Tk_Font	tkfont = SVtoFont(ST(0))
;
	SV *	name = ST(1)
;
	int	RETVAL;
	dXSTARG;

	RETVAL = Tk_PostscriptFontName(tkfont, &name);
	ST(1) = name;
	SvSETMAGIC(ST(1));
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk_SystemEncoding); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_SystemEncoding)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	SV *	RETVAL;

	RETVAL = Lang_SystemEncoding();
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk_abort); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_abort)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	abort();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk_tainting); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_tainting)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = Tk_tainting();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk_tainted); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_tainted)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "sv = NULL");
    {
	SV *	sv;
	int	RETVAL;
	dXSTARG;

	if (items < 1)
	    sv = NULL;
	else {
	    sv = ST(0)
;
	}

	RETVAL = Tk_tainted(sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Tk_DebugHook); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_DebugHook)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "arg");
    {
	SV *	arg = ST(0)
;

	DebugHook(arg);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Tk_ClearErrorInfo); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Tk_ClearErrorInfo)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	SV *	win = ST(0)
;

	ClearErrorInfo(win);
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Tk); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Tk)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        (void)newXSproto_portable("Tk::FontRankInfo::encoding", XS_Tk__FontRankInfo_encoding, file, "$");
        (void)newXSproto_portable("Tk::FontRankInfo::foundary", XS_Tk__FontRankInfo_foundary, file, "$");
        (void)newXSproto_portable("Tk::FontRankInfo::Xname", XS_Tk__FontRankInfo_Xname, file, "$");
        (void)newXSproto_portable("Tk::FontRankInfo::family", XS_Tk__FontRankInfo_family, file, "$");
        (void)newXSproto_portable("Tk::FontRankInfo::size", XS_Tk__FontRankInfo_size, file, "$");
        (void)newXSproto_portable("Tk::FontRankInfo::bold", XS_Tk__FontRankInfo_bold, file, "$");
        (void)newXSproto_portable("Tk::FontRankInfo::italic", XS_Tk__FontRankInfo_italic, file, "$");
        (void)newXSproto_portable("Tk::BLACK", XS_Tk_BLACK, file, "");
        (void)newXSproto_portable("Tk::WHITE", XS_Tk_WHITE, file, "");
        (void)newXSproto_portable("Tk::NORMAL_BG", XS_Tk_NORMAL_BG, file, "");
        (void)newXSproto_portable("Tk::ACTIVE_BG", XS_Tk_ACTIVE_BG, file, "");
        (void)newXSproto_portable("Tk::SELECT_BG", XS_Tk_SELECT_BG, file, "");
        (void)newXSproto_portable("Tk::SELECT_FG", XS_Tk_SELECT_FG, file, "");
        (void)newXSproto_portable("Tk::TROUGH", XS_Tk_TROUGH, file, "");
        (void)newXSproto_portable("Tk::INDICATOR", XS_Tk_INDICATOR, file, "");
        (void)newXSproto_portable("Tk::DISABLED", XS_Tk_DISABLED, file, "");
        (void)newXSproto_portable("Tk::DONT_WAIT", XS_Tk_DONT_WAIT, file, "");
        (void)newXSproto_portable("Tk::WINDOW_EVENTS", XS_Tk_WINDOW_EVENTS, file, "");
        (void)newXSproto_portable("Tk::FILE_EVENTS", XS_Tk_FILE_EVENTS, file, "");
        (void)newXSproto_portable("Tk::TIMER_EVENTS", XS_Tk_TIMER_EVENTS, file, "");
        (void)newXSproto_portable("Tk::IDLE_EVENTS", XS_Tk_IDLE_EVENTS, file, "");
        (void)newXSproto_portable("Tk::ALL_EVENTS", XS_Tk_ALL_EVENTS, file, "");
        newXS_deffile("Tk::Xrm::import", XS_Tk__Xrm_import);
        newXS_deffile("XEvent::Info", XS_XEvent_Info);
        newXS_deffile("XEvent::DESTROY", XS_XEvent_DESTROY);
        newXS_deffile("Tk::MainWindow::Synchronize", XS_Tk__MainWindow_Synchronize);
        newXS_deffile("Tk::MainWindow::Count", XS_Tk__MainWindow_Count);
        newXS_deffile("Tk::Callback::new", XS_Tk__Callback_new);
        newXS_deffile("Tk::Callback::Substitute", XS_Tk__Callback_Substitute);
        newXS_deffile("Tk::NeedPreload", XS_Tk_NeedPreload);
        newXS_deffile("Tk::Preload", XS_Tk_Preload);
        newXS_deffile("Tk::timeofday", XS_Tk_timeofday);
        newXS_deffile("Tk::GetFocusWin", XS_Tk_GetFocusWin);
        newXS_deffile("Tk::GetPointerCoords", XS_Tk_GetPointerCoords);
        newXS_deffile("Tk::CheckHash", XS_Tk_CheckHash);
        newXS_deffile("Tk::Debug", XS_Tk_Debug);
        newXS_deffile("Tk::WidgetMethod", XS_Tk_WidgetMethod);
        newXS_deffile("Tk::OldEnterMethods", XS_Tk_OldEnterMethods);
        newXS_deffile("Tk::GetFILE", XS_Tk_GetFILE);
        newXS_deffile("Tk::Widget::PointToWindow", XS_Tk__Widget_PointToWindow);
        newXS_deffile("Tk::Widget::WindowXY", XS_Tk__Widget_WindowXY);
        newXS_deffile("Tk::Widget::DefineBitmap", XS_Tk__Widget_DefineBitmap);
        newXS_deffile("Tk::Widget::GetBitmap", XS_Tk__Widget_GetBitmap);
        newXS_deffile("Tk::Widget::UnmanageGeometry", XS_Tk__Widget_UnmanageGeometry);
        newXS_deffile("Tk::Widget::DisableButtonEvents", XS_Tk__Widget_DisableButtonEvents);
        newXS_deffile("Tk::Widget::MakeAtom", XS_Tk__Widget_MakeAtom);
        newXS_deffile("Tk::Widget::SendClientMessage", XS_Tk__Widget_SendClientMessage);
#if XSubPPtmpAAAA
        newXS_deffile("Tk::Widget::SendNetWMClientMessage", XS_Tk__Widget_SendNetWMClientMessage);
#endif
        newXS_deffile("Tk::Widget::XSync", XS_Tk__Widget_XSync);
        newXS_deffile("Tk::Widget::GetRootCoords", XS_Tk__Widget_GetRootCoords);
        newXS_deffile("Tk::Widget::GetVRootGeometry", XS_Tk__Widget_GetVRootGeometry);
        newXS_deffile("Tk::Widget::Colormap", XS_Tk__Widget_Colormap);
        newXS_deffile("Tk::Widget::Display", XS_Tk__Widget_Display);
        newXS_deffile("Tk::Widget::ScreenNumber", XS_Tk__Widget_ScreenNumber);
        newXS_deffile("Tk::Widget::Screen", XS_Tk__Widget_Screen);
        newXS_deffile("Tk::Widget::Visual", XS_Tk__Widget_Visual);
        newXS_deffile("Tk::Widget::WindowId", XS_Tk__Widget_WindowId);
        newXS_deffile("Tk::Widget::X", XS_Tk__Widget_X);
        newXS_deffile("Tk::Widget::Y", XS_Tk__Widget_Y);
        newXS_deffile("Tk::Widget::ReqWidth", XS_Tk__Widget_ReqWidth);
        newXS_deffile("Tk::Widget::ReqHeight", XS_Tk__Widget_ReqHeight);
        newXS_deffile("Tk::Widget::Width", XS_Tk__Widget_Width);
        newXS_deffile("Tk::Widget::Height", XS_Tk__Widget_Height);
        newXS_deffile("Tk::Widget::IsMapped", XS_Tk__Widget_IsMapped);
        newXS_deffile("Tk::Widget::Depth", XS_Tk__Widget_Depth);
        newXS_deffile("Tk::Widget::InternalBorderWidth", XS_Tk__Widget_InternalBorderWidth);
        newXS_deffile("Tk::Widget::IsTopLevel", XS_Tk__Widget_IsTopLevel);
        newXS_deffile("Tk::Widget::Name", XS_Tk__Widget_Name);
        newXS_deffile("Tk::Widget::PathName", XS_Tk__Widget_PathName);
        newXS_deffile("Tk::Widget::Class", XS_Tk__Widget_Class);
        newXS_deffile("Tk::Widget::MakeWindowExist", XS_Tk__Widget_MakeWindowExist);
        newXS_deffile("Tk::Widget::SetClass", XS_Tk__Widget_SetClass);
        newXS_deffile("Tk::Widget::MoveWindow", XS_Tk__Widget_MoveWindow);
        newXS_deffile("Tk::Widget::XRaiseWindow", XS_Tk__Widget_XRaiseWindow);
        newXS_deffile("Tk::Widget::MoveToplevelWindow", XS_Tk__Widget_MoveToplevelWindow);
        newXS_deffile("Tk::Widget::MoveResizeWindow", XS_Tk__Widget_MoveResizeWindow);
        newXS_deffile("Tk::Widget::ResizeWindow", XS_Tk__Widget_ResizeWindow);
        newXS_deffile("Tk::Widget::GeometryRequest", XS_Tk__Widget_GeometryRequest);
        newXS_deffile("Tk::Widget::MaintainGeometry", XS_Tk__Widget_MaintainGeometry);
        newXS_deffile("Tk::Widget::SetGrid", XS_Tk__Widget_SetGrid);
        newXS_deffile("Tk::Widget::UnmaintainGeometry", XS_Tk__Widget_UnmaintainGeometry);
        newXS_deffile("Tk::Widget::MapWindow", XS_Tk__Widget_MapWindow);
        newXS_deffile("Tk::Widget::UnmapWindow", XS_Tk__Widget_UnmapWindow);
        newXS_deffile("Tk::Widget::UnsetGrid", XS_Tk__Widget_UnsetGrid);
        newXS_deffile("Tk::Widget::AddOption", XS_Tk__Widget_AddOption);
        newXS_deffile("Tk::Widget::GetAtomName", XS_Tk__Widget_GetAtomName);
        newXS_deffile("Tk::Widget::ClearSelection", XS_Tk__Widget_ClearSelection);
        newXS_deffile("Tk::Widget::DisplayName", XS_Tk__Widget_DisplayName);
        newXS_deffile("Tk::Widget::GetOption", XS_Tk__Widget_GetOption);
        newXS_deffile("Tk::Widget::InternAtom", XS_Tk__Widget_InternAtom);
        newXS_deffile("Tk::Widget::Ungrab", XS_Tk__Widget_Ungrab);
        newXS_deffile("Tk::Widget::SetAppName", XS_Tk__Widget_SetAppName);
        newXS_deffile("Tk::Widget::IsWidget", XS_Tk__Widget_IsWidget);
        newXS_deffile("Tk::Widget::Grab", XS_Tk__Widget_Grab);
        newXS_deffile("Tk::Widget::Widget", XS_Tk__Widget_Widget);
        newXS_deffile("Tk::Widget::_object", XS_Tk__Widget__object);
        newXS_deffile("Tk::Widget::Containing", XS_Tk__Widget_Containing);
        newXS_deffile("Tk::Widget::Parent", XS_Tk__Widget_Parent);
        newXS_deffile("Tk::Widget::MainWindow", XS_Tk__Widget_MainWindow);
        newXS_deffile("Tk::AddErrorInfo", XS_Tk_AddErrorInfo);
        newXS_deffile("Tk::BackgroundError", XS_Tk_BackgroundError);
        newXS_deffile("Tk::Fail", XS_Tk_Fail);
        newXS_deffile("Tk::DoOneEvent", XS_Tk_DoOneEvent);
        newXS_deffile("Tk::Font::DESTROY", XS_Tk__Font_DESTROY);
        newXS_deffile("Tk::Font::PostscriptFontName", XS_Tk__Font_PostscriptFontName);
        newXS_deffile("Tk::SystemEncoding", XS_Tk_SystemEncoding);
        newXS_deffile("Tk::abort", XS_Tk_abort);
        newXS_deffile("Tk::tainting", XS_Tk_tainting);
        newXS_deffile("Tk::tainted", XS_Tk_tainted);
        newXS_deffile("Tk::DebugHook", XS_Tk_DebugHook);
        newXS_deffile("Tk::ClearErrorInfo", XS_Tk_ClearErrorInfo);

    /* Initialisation Section */

#if XSubPPtmpAAAA
#endif
#line 1169 "Tk.xs"
 {
  Boot_Glue(aTHX);
#ifdef WIN32
  /* Force inclusion of DllMain() */
  TkWin32DllPresent();
  TkWinXInit(Tk_GetHINSTANCE());
#endif
  /* We need to call Tcl_Preserve() on something so
     its exit handler is first on the list, and so last
     to be called
   */
  Tcl_Preserve((ClientData) cv);
  Tcl_Release((ClientData) cv);
}

#line 3110 "Tk.c"

    /* End of Initialisation Section */

#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

