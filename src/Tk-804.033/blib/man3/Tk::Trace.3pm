.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Tk::Trace 3pm"
.TH Tk::Trace 3pm "2018-12-25" "Tk804.033" "perl/Tk Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Tk::Trace \- emulate Tcl/Tk trace functions.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Tk::Trace
\&
\& $mw\->traceVariable(\e$v, \*(Aqwru\*(Aq => [\e&update_meter, $scale]);
\& %vinfo = $mw\->traceVinfo(\e$v);
\& print "Trace info  :\en  ", join("\en  ", @{$vinfo{\-legible}}), "\en";
\& $mw\->traceVdelete(\e$v);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class module emulates the Tcl/Tk \fBtrace\fR family of commands by
binding subroutines of your devising to Perl variables using simple
\&\fBTie::Watch\fR features.
.PP
Callback format is patterned after the Perl/Tk scheme: supply either a
code reference, or, supply an array reference and pass the callback
code reference in the first element of the array, followed by callback
arguments.
.PP
User callbacks are passed these arguments:
.PP
.Vb 4
\& $_[0]        = undef for a scalar, index/key for array/hash
\& $_[1]        = variable\*(Aqs current (read), new (write), final (undef) value
\& $_[2]        = operation (r, w, or u)
\& $_[3 .. $#_] = optional user callback arguments
.Ve
.PP
As a Trace user, you have an important responsibility when writing your
callback, since you control the final value assigned to the variable.
A typical callback might look like:
.PP
.Vb 6
\& sub callback {
\&    my($index, $value, $op, @args) = @_;
\&    return if $op eq \*(Aqu\*(Aq;
\&    # .... code which uses $value ...
\&    return $value;     # variable\*(Aqs final value
\& }
.Ve
.PP
Note that the callback's return value becomes the variable's final value,
for either read or write traces.
.PP
For write operations, the variable is updated with its new value before
the callback is invoked.
.PP
Multiple read, write and undef callbacks can be attached to a variable,
which are invoked in reverse order of creation.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$mw\->traceVariable(varRef, op => callback);" 4
.el .IP "\f(CW$mw\fR\->traceVariable(varRef, op => callback);" 4
.IX Item "$mw->traceVariable(varRef, op => callback);"
\&\fBvarRef\fR is a reference to the scalar, array or hash variable you
wish to trace.  \fBop\fR is the trace operation, and can be any combination
of \fBr\fR for read, \fBw\fR for write, and \fBu\fR for undef.  \fBcallback\fR is a
standard Perl/Tk callback, and is invoked, depending upon the value of
\&\fBop\fR, whenever the variable is read, written, or destroyed.
.ie n .IP "%vinfo = $mw\->traceVinfo(varRef);" 4
.el .IP "\f(CW%vinfo\fR = \f(CW$mw\fR\->traceVinfo(varRef);" 4
.IX Item "%vinfo = $mw->traceVinfo(varRef);"
Returns a hash detailing the internals of the Trace object, with these
keys:
.Sp
.Vb 10
\& %vinfo = (
\&     \-variable =>  varRef
\&     \-debug    =>  \*(Aq0\*(Aq
\&     \-shadow   =>  \*(Aq1\*(Aq
\&     \-value    =>  \*(AqHELLO SCALAR\*(Aq
\&     \-destroy  =>  callback
\&     \-fetch    =>  callback
\&     \-store    =>  callback
\&     \-legible  =>  above data formatted as a list of string, for printing
\& );
.Ve
.Sp
For array and hash Trace objects, the \fB\-value\fR key is replaced with a
\&\fB\-ptr\fR key which is a reference to the parallel array or hash.
Additionally, for an array or hash, there are key/value pairs for
all the variable specific callbacks.
.ie n .IP "$mw\->traceVdelete(\e$v);" 4
.el .IP "\f(CW$mw\fR\->traceVdelete(\e$v);" 4
.IX Item "$mw->traceVdelete($v);"
Stop tracing the variable.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 1
\& # Trace a Scale\*(Aqs variable and move a meter in unison.
\&
\& use Tk;
\& use Tk::widgets qw/Trace/;
\&
\& $pi = 3.1415926;
\& $mw = MainWindow\->new;
\& $c = $mw\->Canvas( qw/\-width 200 \-height 110 \-bd 2 \-relief sunken/ )\->grid;
\& $c\->createLine( qw/100 100 10 100 \-tag meter \-arrow last \-width 5/ );
\& $s = $mw\->Scale( qw/\-orient h \-from 0 \-to 100 \-variable/ => \e$v )\->grid;
\& $mw\->Label( \-text => \*(AqSlide Me for 5 Seconds\*(Aq )\->grid;
\&
\& $mw\->traceVariable( \e$v, \*(Aqw\*(Aq => [ \e&update_meter, $s ] );
\&
\& $mw\->after( 5000 => sub {
\&     print "Untrace time ...\en";
\&     %vinfo = $s\->traceVinfo( \e$v );
\&     print "Watch info  :\en  ", join("\en  ", @{$vinfo{\-legible}}), "\en";
\&     $c\->traceVdelete( \e$v );
\& });
\&
\& MainLoop;
\&
\& sub update_meter {
\&     my( $index, $value, $op, @args ) = @_;
\&     return if $op eq \*(Aqu\*(Aq;
\&     $min = $s\->cget( \-from );
\&     $max = $s\->cget( \-to );
\&     $pos = $value / abs( $max \- $min );
\&     $x = 100.0 \- 90.0 * ( cos( $pos * $pi ) );
\&     $y = 100.0 \- 90.0 * ( sin( $pos * $pi ) );
\&     $c\->coords( qw/meter 100 100/, $x, $y );
\&     return $value;
\& }
\&
\& # Predictive text entry.
\&
\& use Tk;
\& use Tk::widgets qw/ LabEntry Trace /;
\& use strict;
\&
\& my @words =  qw/radio television telephone turntable microphone/;
\&
\& my $mw = MainWindow\->new;
\&
\& my $e = $mw\->LabEntry(
\&     qw/ \-label Thing \-width 40 /,
\&     \-labelPack    => [ qw/ \-side left / ],
\&     \-textvariable => \emy $thing,
\& );
\& my $t = $mw\->Text( qw/ \-height 10 \-width 50 / );;
\&
\& $t\->pack( $e, qw/ \-side top / );
\&
\& $e\->focus;
\& $e\->traceVariable( \e$thing, \*(Aqw\*(Aq, [ \e&trace_thing, $e, $t ] );
\&
\& foreach my $k ( 1 .. 12 ) {
\&     $e\->bind( "<F${k}>" => [ \e&ins, $t, Ev(\*(AqK\*(Aq) ] );
\& }
\& $e\->bind( \*(Aq<Return>\*(Aq =>
\&           sub {
\&               print "$thing\en";
\&               $_[0]\->delete( 0, \*(Aqend\*(Aq );
\&           }
\& );
\&
\& MainLoop;
\&
\& sub trace_thing {
\&
\&     my( $index, $value, $op, $e, $t ) = @_;
\&
\&     return unless $value;
\&
\&     $t\->delete( qw/ 1.0 end / );
\&     foreach my $w ( @words ) {
\&         if ( $w =~ /^$value/ ) {
\&             $t\->insert( \*(Aqend\*(Aq, "$w\en" );
\&         }
\&     }
\&
\&     return $value;
\&
\& } # end trace_thing
\&
\& sub ins {
\&
\&     my( $e, $t, $K ) = @_;
\&
\&     my( $index ) = $K =~ /^F(\ed+)$/;
\&
\&     $e\->delete( 0, \*(Aqend\*(Aq );
\&     $e\->insert( \*(Aqend\*(Aq, $t\->get( "$index.0", "$index.0 lineend" ) );
\&     $t\->delete( qw/ 1.0 end / );
\&
\& } # end ins
.Ve
.SH "HISTORY"
.IX Header "HISTORY"
.Vb 2
\& Stephen.O.Lidie@Lehigh.EDU, Lehigh University Computing Center, 2000/08/01
\& . Version 1.0, for Tk800.022.
\&
\& sol0@Lehigh.EDU, Lehigh University Computing Center, 2003/09/22
\& . Version 1.1, for Tk804.025, add support for multiple traces of the same
\&   type on the same variable.
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2000 \- 2003 Stephen O. Lidie. All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
