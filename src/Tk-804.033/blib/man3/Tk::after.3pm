.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "after 3pm"
.TH after 3pm "2018-12-25" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Tk::after \- Execute a command after a time delay
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
  \fI\f(CI$widget\fI\fR\->\fBafter\fR(\fIms\fR)
.PP
  \fI\f(CI$id\fI\fR = \fI\f(CI$widget\fI\fR\->\fBafter\fR(\fIms\fR?,\fIcallback\fR?)
.PP
  \fI\f(CI$id\fI\fR = \fI\f(CI$widget\fI\fR\->\fBrepeat\fR(\fIms\fR?,\fIcallback\fR?)
.PP
  \fI\f(CI$widget\fI\fR\->\fBafterCancel\fR(\fI\f(CI$id\fI\fR)
.PP
  \fI\f(CI$id\fI\fR = \fI\f(CI$widget\fI\fR\->\fBafterIdle\fR(\fIcallback\fR)
.PP
  \fI\f(CI$widget\fI\fR\->\fBafterInfo\fR?(\fI\f(CI$id\fI\fR)?
.PP
  \fI\f(CI$id\fI\fR\->\fBtime\fR(?\fIdelay\fR?)
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This method is used to delay execution of the program or to execute
a callback in background sometime in the future.
.PP
In perl/Tk \fI\f(CI$widget\fI\fR\->\fBafter\fR is implemented via the class \f(CW\*(C`Tk::After\*(C'\fR,
and callbacks are associated with \fI\f(CI$widget\fI\fR, and are automatically cancelled
when the widget is destroyed. An almost identical interface, but without
automatic cancel, and without repeat is provided via Tk::after method.
.SS "Internal Details"
.IX Subsection "Internal Details"
The internal Tk::After class has the following synopsis:
.PP
.Vb 4
\&  $id = Tk::After\->new($widget, tid, $time, \*(Aqonce\*(Aq,   callback);
\&  $id = Tk::After\->new($widget, tid, $time, \*(Aqrepeat\*(Aq, callback);
\&  $id\->cancel;
\&  $id\->time(?delay?);
.Ve
.PP
\&\f(CW$id\fR is a Tk::After object, an array of 5 elements:
.PP
\&\fI\f(CI$widget\fI\fR is the parent widget reference.
.PP
\&\fItid\fR is the internal timer id, a unique string.
.PP
\&\fI\f(CI$time\fI\fR is the string 'idle', representing an idle queue timer, or a
integer millisecond value.
.PP
\&\fIonce\fR or \fIrepeat\fR specifies whether the timer is a one-time \fBafter\fR
event, or a repeating \fBrepeat\fR event.
.PP
\&\fIcallback\fR specifies a Perl/Tk Tk::Callback object.
.SH "Changing a \fBrepeat\fP timer interval"
.IX Header "Changing a repeat timer interval"
It's posible to change a \fBrepeat\fR timer's delay value, or even cancel
any timer, using the \fBtime\fR method. If \fIdelay\fR is specified and
non-zero, a new timer delay is established.  If \fIdelay\fR is zero the
timer event is canceled just as if \fI\f(CI$id\fI\fR\->\fBcancel\fR were invoked.
In all cases the current millisecond timer delay is returned.
.PP
Note: the new timer delay will take effect on the \fIsubsequent\fR timer
event \- this command will not cancel the pending timer event and
re-issue it with the new delay time.
.SH "The \fIafter()\fP method has several forms as follows:"
.IX Header "The after() method has several forms as follows:"
.IP "\fI\f(CI$widget\fI\fR\->\fBafter\fR(\fIms\fR)" 4
.IX Item "$widget->after(ms)"
The value \fIms\fR must be an integer giving a time in milliseconds.
The command sleeps for \fIms\fR milliseconds and then returns.
While the command is sleeping the application does not respond to
events.
.IP "\fI\f(CI$widget\fI\fR\->\fBafter\fR(\fIms\fR,\fIcallback\fR)" 4
.IX Item "$widget->after(ms,callback)"
In this form the command returns immediately, but it arranges
for \fIcallback\fR be executed \fIms\fR milliseconds later as an
event handler.
The callback will be executed exactly once, at the given time.
The command will be executed in context of \fI\f(CI$widget\fI\fR.
If an error occurs while executing the delayed command then the
Tk::Error mechanism is used to report the error.
The \fBafter\fR command returns an identifier (an object in the perl/Tk
case) that can be used to cancel the delayed command using \fBafterCancel\fR.
.IP "\fI\f(CI$widget\fI\fR\->\fBrepeat\fR(\fIms\fR,\fIcallback\fR)" 4
.IX Item "$widget->repeat(ms,callback)"
In this form the command returns immediately, but it arranges
for \fIcallback\fR be executed \fIms\fR milliseconds later as an
event handler. After \fIcallback\fR has executed it is re-scheduled,
to be executed in a futher \fIms\fR, and so on until it is cancelled.
.IP "\fI\f(CI$widget\fI\fR\->\fBafterCancel\fR(\fI\f(CI$id\fI\fR)" 4
.IX Item "$widget->afterCancel($id)"
.PD 0
.IP "\fI\f(CI$id\fI\fR\->\fBcancel\fR" 4
.IX Item "$id->cancel"
.PD
Cancels the execution of a delayed command that
was previously scheduled.
\&\fI\f(CI$id\fI\fR indicates which command should be canceled;  it must have
been the return value from a previous \fBafter\fR command.
If the command given by \fI\f(CI$id\fI\fR has already been executed (and
is not scheduled to be executed again) then \fBafterCancel\fR
has no effect.
.IP "\fI\f(CI$widget\fI\fR\->\fBafterCancel\fR(\fIcallback\fR)" 4
.IX Item "$widget->afterCancel(callback)"
\&\fIThis form is not robust in perl/Tk \- its use is deprecated.\fR
This command should also cancel the execution of a delayed command.
The \fIcallback\fR argument is compared with pending callbacks,
if a match is found, that callback is
cancelled and will never be executed;  if no such callback is
currently pending then the \fBafterCancel\fR has no effect.
.IP "\fI\f(CI$widget\fI\fR\->\fBafterIdle\fR(\fIcallback\fR)" 4
.IX Item "$widget->afterIdle(callback)"
Arranges for \fIcallback\fR to be evaluated later as an idle callback.
The script will be run exactly once, the next time the event
loop is entered and there are no events to process.
The command returns an identifier that can be used
to cancel the delayed command using \fBafterCancel\fR.
If an error occurs while executing the script then the
Tk::Error mechanism is used to report the error.
.IP "\fI\f(CI$widget\fI\fR\->\fBafterInfo\fR?(\fI\f(CI$id\fI\fR)?" 4
.IX Item "$widget->afterInfo?($id)?"
This command returns information about existing event handlers.  If no
\&\fI\f(CI$id\fI\fR argument is supplied, the command returns a list of the
identifiers for all existing event handlers created by the \fBafter\fR
and \fBrepeat\fR commands for \fI\f(CI$widget\fI\fR. If \fI\f(CI$id\fI\fR is supplied, it
specifies an existing handler; \fI\f(CI$id\fI\fR must have been the return value
from some previous call to \fBafter\fR or \fBrepeat\fR and it must not have
triggered yet or been cancelled. In this case the command returns a
list with three elements.  The first element of the list is the
callback associated with \fI\f(CI$id\fI\fR, the second element is either \fBidle\fR
or the \fIinteger\fR timer millisecond value to indicate what kind of
event handler it is, and the third is a string \fIonce\fR or \fIrepeat\fR to
differentiate an \fBafter\fR from a \fBrepeat\fR event.
.PP
The \fBafter\fR(\fIms\fR) and \fBafterIdle\fR forms of the command
assume that the application is event driven:  the delayed commands
will not be executed unless the application enters the event loop.
In applications that are not normally event-driven,
the event loop can be entered with the \fBvwait\fR and \fBupdate\fR commands.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Tk::Error
Tk::callbacks
.SH "KEYWORDS"
.IX Header "KEYWORDS"
cancel, delay, idle callback, sleep, time
