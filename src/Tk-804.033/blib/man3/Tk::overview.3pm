.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "overview 3pm"
.TH overview 3pm "2018-12-25" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Tk::overview \- An overview of an Object Oriented Tk8 extension for perl5
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\f(CW\*(C`use Tk;\*(C'\fR
.PP
\&\f(CW\*(C`$main = MainWindow\->new();\*(C'\fR
.PP
\&\f(CW\*(C`$widget = $main\->\f(CIWidget\f(CW(...);\*(C'\fR
.PP
\&\f(CW\*(C`$widget\->pack(...);\*(C'\fR
.PP
\&...
.PP
\&\f(CW\*(C`MainLoop;\*(C'\fR
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
In writing the perl Tk extension, the goals were to provide a complete
interface to the latest production version of John Ousterhout's Tk, while providing
an Object Oriented interface to perl code.
.SH "CONTENTS"
.IX Header "CONTENTS"
The package is composed of three loosely connected parts:
.IP "\fIpTk\fR \- Converted Tk source" 4
.IX Item "pTk - Converted Tk source"
The \fIpTk\fR sub-directory is a copy of the C code of Tk8.x, modified
to allow use by languages other than the original Tcl.
(The pTk can be read as 'perl' Tk or 'portable' Tk, depending on
your sensibilities.)
.IP "\fBTk\fR to Perl 'Glue'" 4
.IX Item "Tk to Perl 'Glue'"
The top level directory provides \fITk.xs\fR and \fItkGlue.c\fR
which provide the perl-callable interfaces to pTk
.IP "Perl code for 'Widget' Classes" 4
.IX Item "Perl code for 'Widget' Classes"
The \fITk\fR sub-directory contains the various perl modules that comprise
the \*(L"Classes\*(R" that are visible to Tk applications.
.Sp
The \*(L"major\*(R" widgets such as \fBTk::Text\fR are actually in separate directories
at the top level (e.g. \fIText/*\fR for \fBTk::Text\fR) and are dynamically
loaded as needed on platforms which support perl5's \fBDynaLoader\fR.
.SH "CLASS HIERARCHY"
.IX Header "CLASS HIERARCHY"
.IP "\fBpackage Tk;\fR \- the 'base class'" 4
.IX Item "package Tk; - the 'base class'"
All the \*(L"command names\*(R" documented in Tcl/Tk are made to look like perl
sub's and reside in the Tk package. Their names are all lower case.
Typically there are very few commands at this level which are called
directly by applications.
.IP "\fBpackage Tk::Widget;\fR \- the 'Widget class'" 4
.IX Item "package Tk::Widget; - the 'Widget class'"
There are no actual objects of the \fBTk::Widget\fR class; however all
the various Tk window \*(L"widgets\*(R" inherit from it, and it in turn
inherits all the core Tk functions from Tk.
.Sp
\&\fBTk::Widget\fR provides various functions and interfaces which are
common to all Widgets.
.Sp
A widget is represented to perl as a blessed reference to a hash. There are some
members of the hash which are private to Tk and its tkGlue code.  Keys
starting with \fB'.'\fR and of the form  \fB/_[A\-Z][A\-Za\-z_]+_/\fR
(i.e. starting and ending in _ and with  first char after _ being upper case) should be
considered reserved to \fBTk\fR.
.IP "\fBTk::Button\fR, \fBTk::Entry\fR, \fBTk::Text\fR ..." 4
.IX Item "Tk::Button, Tk::Entry, Tk::Text ..."
There is one class for each of the \*(L"Tk\*(R" widget item types.
Some of them like \fBTk::Frame\fR do very little indeed, and really
only exist so that they can be derived from or so that focus or menu
traversal can discover the \*(L"kind\*(R" of window being processed.
.Sp
Other classes, \fBTk::Text\fR for example, provide a lot of methods
used with Tk's \*(L"bind\*(R" to provide a rich keyboard/mouse interface
to the widgets' data.
.Sp
These widget classes also include conversions of the Tcl code for
event bindings, keyboard focus traversal, menu bars, and menu keyboard
traversal. All the Tcl functions have been converted, but the names have
changed (systematically) and they have been split up between the various
classes in what I hope is an appropriate manner.
Name changes are normally: dropping initial tk_ as the Tk-ness is implicit
in the \fBTk::\fR prefix, and similarly dropping say Menu from the name if it
has been moved the Tk::Menu class.
Thus 'proc tkMenuNextEntry' becomes 'sub NextEntry' in the Tk::Menu package.
.IP "\fBTk::Image\fR" 4
.IX Item "Tk::Image"
This does for Tk8.x's \*(L"images\*(R" what \fBTk::Widget\fR does for widgets.
Images are new to Tk8.x and the class structure is not mature either.
.Sp
There are three sub-classes \fBTk::Bitmap\fR, \fBTk::Pixmap\fR and \fBTk::Photo\fR.
.Sp
It is possible to create dynamic or auto-loaded image types inherited
from \fBTk::Image\fR for other image types or photo formats (e.g. support
for \s-1TIFF\s0 format).
.IP "Composite Widgets" 4
.IX Item "Composite Widgets"
A composite is some kind of 'frame' with subwidgets which give it useful behaviour.
\&\fBTk::Dialog\fR is an example of
a composite widget classes built from the basic \fBTk\fR ones.
It is intended that user code should not need to be aware that a particular
class is a composite, and create and configure such widgets in the same manner
as any other kind. The \fBconfigure\fR mechanism and the methods of the
class manipulate the subwidgets as required.
.Sp
Composite widgets are implemented via \fBTk::Frame\fR and multiple inheritance.
The two 'frame' base classes \fBTk::Frame\fR and
\&\fBTk::Toplevel\fR include the additional class \fBTk::Derived\fR
in their inheritance. \fBTk::Derived\fR provides methods to allow additional
\&\fBconfigure\fR options to be defined for a widget.
.Sp
A Composite widget is typically defined as derived
from \fBTk::Frame\fR or \fBTk::Toplevel\fR
(e.g. \fBTk::Dialog\fR).
